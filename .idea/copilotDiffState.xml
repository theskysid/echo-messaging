<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/INTERNAL_ARCHITECTURE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/INTERNAL_ARCHITECTURE.md" />
              <option name="updatedContent" value="# Echo Messaging - Internal Architecture Documentation&#10;&#10;## Table of Contents&#10;1. [Project Overview](#project-overview)&#10;2. [Technology Stack](#technology-stack)&#10;3. [Architecture Overview](#architecture-overview)&#10;4. [Backend Deep Dive](#backend-deep-dive)&#10;5. [Frontend Deep Dive](#frontend-deep-dive)&#10;6. [Data Flow &amp; Communication](#data-flow--communication)&#10;7. [Security Implementation](#security-implementation)&#10;8. [WebSocket Communication](#websocket-communication)&#10;9. [Database Schema](#database-schema)&#10;10. [Key Features Implementation](#key-features-implementation)&#10;&#10;---&#10;&#10;## Project Overview&#10;&#10;Echo is a real-time messaging application that enables users to:&#10;- Register and authenticate securely&#10;- Send public messages to all online users&#10;- Send private messages to specific users&#10;- See online/offline user status in real-time&#10;- Experience instant message delivery via WebSocket connections&#10;&#10;---&#10;&#10;## Technology Stack&#10;&#10;### Backend&#10;- **Framework**: Spring Boot 3.3.4&#10;- **Language**: Java 21&#10;- **Security**: Spring Security 6 + JWT Authentication&#10;- **WebSocket**: STOMP over SockJS&#10;- **Database**: H2 (in-memory)&#10;- **ORM**: Spring Data JPA / Hibernate&#10;- **Build Tool**: Maven&#10;&#10;### Frontend&#10;- **Framework**: React 19&#10;- **Build Tool**: Vite&#10;- **Routing**: React Router v7&#10;- **HTTP Client**: Axios&#10;- **WebSocket**: SockJS Client + STOMP.js&#10;- **Styling**: CSS Modules&#10;&#10;---&#10;&#10;## Architecture Overview&#10;&#10;```&#10;┌─────────────────────────────────────────────────────────────────┐&#10;│                         CLIENT (React)                          │&#10;│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │&#10;│  │   Login/     │  │   ChatArea   │  │   PrivateChat       │  │&#10;│  │   Signup     │  │   Component  │  │   Component         │  │&#10;│  └──────────────┘  └──────────────┘  └──────────────────────┘  │&#10;│         │                  │                    │                │&#10;│         └──────────────────┼────────────────────┘                │&#10;│                            │                                     │&#10;└────────────────────────────┼─────────────────────────────────────┘&#10;                             │&#10;                    ┌────────┴─────────┐&#10;                    │   HTTP / WS      │&#10;                    └────────┬─────────┘&#10;                             │&#10;┌────────────────────────────┼─────────────────────────────────────┐&#10;│                    SPRING BOOT BACKEND                           │&#10;│  ┌──────────────────────────────────────────────────────────┐   │&#10;│  │              Security Filter Chain                       │   │&#10;│  │  ┌─────────────────┐    ┌────────────────────────┐      │   │&#10;│  │  │ CORS Config     │───▶│ JwtAuthFilter          │      │   │&#10;│  │  └─────────────────┘    └────────────────────────┘      │   │&#10;│  └──────────────────────────────────────────────────────────┘   │&#10;│                             │                                    │&#10;│  ┌──────────────┬───────────┼───────────┬──────────────────┐   │&#10;│  │              │           │           │                  │   │&#10;│  │ ┌────────────▼──┐  ┌────▼────────┐  ┌─────────────────▼─┐ │&#10;│  │ │ AuthController│  │ChatController│  │MessageController │ │&#10;│  │ └────────────┬──┘  └────┬────────┘  └─────────────────┬─┘ │&#10;│  │              │           │                             │   │&#10;│  │ ┌────────────▼──────┐  ┌▼────────────────┐  ┌─────────▼──┐ │&#10;│  │ │AuthenticationSvc │  │  UserService    │  │   Repos    │ │&#10;│  │ │    JwtService    │  │                 │  │            │ │&#10;│  │ └──────────────────┘  └─────────────────┘  └────────────┘ │&#10;│  │                                                            │ │&#10;│  │ ┌──────────────────────────────────────────────────────┐ │ │&#10;│  │ │            WebSocket Configuration                   │ │ │&#10;│  │ │  • /ws endpoint (SockJS)                            │ │ │&#10;│  │ │  • /topic/public (broadcast)                        │ │ │&#10;│  │ │  • /user/{username}/queue/private (private)         │ │ │&#10;│  │ │  • /app/* (application destination prefix)          │ │ │&#10;│  │ └──────────────────────────────────────────────────────┘ │ │&#10;│  └──────────────────────────────────────────────────────────┘ │&#10;│                             │                                    │&#10;│  ┌──────────────────────────▼──────────────────────────────┐   │&#10;│  │              H2 In-Memory Database                      │   │&#10;│  │  ┌─────────────┐           ┌──────────────────┐        │   │&#10;│  │  │  users      │           │  chat_messages   │        │   │&#10;│  │  └─────────────┘           └──────────────────┘        │   │&#10;│  └─────────────────────────────────────────────────────────┘   │&#10;└────────────────────────────────────────────────────────────────┘&#10;```&#10;&#10;---&#10;&#10;## Backend Deep Dive&#10;&#10;### 1. Application Entry Point&#10;&#10;**File**: `EchoBackendApplication.java`&#10;&#10;```java&#10;@SpringBootApplication&#10;public class EchoBackendApplication {&#10;    public static void main(String[] args) {&#10;        SpringApplication.run(EchoBackendApplication.class, args);&#10;    }&#10;}&#10;```&#10;&#10;The `@SpringBootApplication` annotation combines:&#10;- `@Configuration`: Marks class as configuration source&#10;- `@EnableAutoConfiguration`: Enables Spring Boot auto-configuration&#10;- `@ComponentScan`: Scans for components in the package&#10;&#10;### 2. Security Layer&#10;&#10;#### SecurityConfig.java&#10;&#10;**Purpose**: Configures HTTP security, CORS, JWT authentication&#10;&#10;**Key Components**:&#10;&#10;```&#10;Request Flow:&#10;HTTP Request → CORS Filter → JWT Filter → Authentication → Controller&#10;```&#10;&#10;- **CSRF**: Disabled (using JWT, not session-based)&#10;- **CORS**: Configured to allow frontend origins (localhost:5173, localhost:3000)&#10;- **Session Management**: STATELESS (no server-side sessions)&#10;- **Public Endpoints**: `/auth/**`, `/ws/**`, `/h2-console/**`&#10;- **Protected Endpoints**: All others require authentication&#10;&#10;**Security Filter Chain**:&#10;1. `JwtAuthenticationFilter` - Extracts &amp; validates JWT from cookies&#10;2. `UsernamePasswordAuthenticationFilter` - Standard Spring Security filter&#10;3. If JWT valid → User authenticated&#10;4. If JWT invalid/missing → 401 Unauthorized&#10;&#10;#### JwtAuthenticationFilter.java&#10;&#10;**Purpose**: Intercepts requests to extract and validate JWT tokens&#10;&#10;**Flow**:&#10;```&#10;1. Extract JWT from Cookie header&#10;2. Extract username from JWT&#10;3. Validate token (signature, expiration)&#10;4. Load user details from database&#10;5. Create Authentication object&#10;6. Set in SecurityContext&#10;```&#10;&#10;#### JwtService.java&#10;&#10;**Purpose**: Handles JWT token generation and validation&#10;&#10;**Key Methods**:&#10;- `generateToken(User)`: Creates JWT with username, userId, expiration&#10;- `extractUsername(String)`: Extracts username from token&#10;- `extractUserId(String)`: Extracts user ID from token&#10;- `isTokenValid(String)`: Validates token signature and expiration&#10;&#10;**Token Structure**:&#10;```json&#10;{&#10;  &quot;sub&quot;: &quot;username&quot;,&#10;  &quot;userId&quot;: &quot;123&quot;,&#10;  &quot;iat&quot;: 1699999999,&#10;  &quot;exp&quot;: 1700003599&#10;}&#10;```&#10;&#10;**Token Lifetime**: 1 hour (3600000ms)&#10;&#10;### 3. WebSocket Configuration&#10;&#10;#### WebSocketConfig.java&#10;&#10;**Purpose**: Configures STOMP messaging over WebSocket&#10;&#10;**Brokers**:&#10;- **Simple Broker**: `/topic`, `/queue`, `/user`&#10;  - `/topic/*` - Broadcast to all subscribers&#10;  - `/queue/*` - Point-to-point queues&#10;  - `/user/*` - User-specific destinations&#10;&#10;**Application Destinations**: `/app/*`&#10;- Client sends to: `/app/chat.sendMessage`&#10;- Server processes via: `@MessageMapping(&quot;/chat.sendMessage&quot;)`&#10;&#10;**STOMP Endpoint**: `/ws`&#10;- Accessible at: `http://localhost:8080/ws`&#10;- Fallback: SockJS (for browsers without WebSocket support)&#10;&#10;#### WebSocket Flow:&#10;```&#10;1. Client connects to /ws via SockJS&#10;2. STOMP handshake established&#10;3. Client subscribes to topics:&#10;   - /topic/public (public chat)&#10;   - /user/{username}/queue/private (private messages)&#10;4. Client sends messages to /app/* destinations&#10;5. Server processes and broadcasts to appropriate topics&#10;```&#10;&#10;### 4. Controllers&#10;&#10;#### AuthController.java&#10;&#10;**Endpoints**:&#10;&#10;| Method | Path | Description | Auth Required |&#10;|--------|------|-------------|---------------|&#10;| POST | `/auth/signup` | Register new user | No |&#10;| POST | `/auth/login` | Authenticate user | No |&#10;| POST | `/auth/logout` | Clear JWT cookie | Yes |&#10;| GET | `/auth/getonlineusers` | Get list of online users | Yes |&#10;| GET | `/auth/getcurrentuser` | Get current user details | Yes |&#10;&#10;**Signup Flow**:&#10;```&#10;1. Validate username uniqueness&#10;2. Hash password with BCrypt&#10;3. Save user to database&#10;4. Return UserDTO (no password)&#10;```&#10;&#10;**Login Flow**:&#10;```&#10;1. Find user by username&#10;2. Authenticate with AuthenticationManager&#10;3. Generate JWT token&#10;4. Set HttpOnly cookie with token&#10;5. Return UserDTO&#10;```&#10;&#10;**Cookie Configuration**:&#10;- `httpOnly: true` - JavaScript cannot access&#10;- `secure: true` - Only sent over HTTPS (production)&#10;- `sameSite: strict` - CSRF protection&#10;- `maxAge: 3600s` - 1 hour expiration&#10;&#10;#### ChatController.java&#10;&#10;**WebSocket Mappings**:&#10;&#10;| Mapping | Destination | Description |&#10;|---------|-------------|-------------|&#10;| `/chat.addUser` | `/topic/public` | User joins chat |&#10;| `/chat.sendMessage` | `/topic/public` | Send public message |&#10;| `/chat.sendPrivateMessage` | `/user/{username}/queue/private` | Send private message |&#10;&#10;**addUser() Flow**:&#10;```&#10;1. Verify user exists in database&#10;2. Store username in WebSocket session attributes&#10;3. Set user online status = true&#10;4. Create JOIN message&#10;5. Save to database&#10;6. Broadcast to /topic/public&#10;```&#10;&#10;**sendMessage() Flow**:&#10;```&#10;1. Verify sender exists&#10;2. Set timestamp (if not provided)&#10;3. Save message to database&#10;4. Broadcast to /topic/public (all subscribers receive)&#10;```&#10;&#10;**sendPrivateMessage() Flow**:&#10;```&#10;1. Verify sender and recipient exist&#10;2. Set message type = PRIVATE_MESSAGE&#10;3. Set timestamp&#10;4. Save to database&#10;5. Send to recipient: /user/{recipient}/queue/private&#10;6. Send to sender: /user/{sender}/queue/private&#10;   (for message sync across sender's devices)&#10;```&#10;&#10;#### MessageController.java&#10;&#10;**REST Endpoints**:&#10;&#10;| Method | Path | Description |&#10;|--------|------|-------------|&#10;| GET | `/api/messages/private?user1=X&amp;user2=Y` | Retrieve chat history between two users |&#10;&#10;**Query Logic**:&#10;```sql&#10;SELECT * FROM chat_messages &#10;WHERE (sender = :user1 AND recipient = :user2)&#10;   OR (sender = :user2 AND recipient = :user1)&#10;ORDER BY timestamp ASC&#10;```&#10;&#10;### 5. Services&#10;&#10;#### AuthenticationService.java&#10;&#10;**Responsibilities**:&#10;- User registration&#10;- User login&#10;- JWT token management&#10;- Online user tracking&#10;&#10;**signup()**:&#10;```&#10;1. Check username availability&#10;2. Hash password (BCrypt)&#10;3. Create User entity&#10;4. Save to database&#10;5. Return UserDTO&#10;```&#10;&#10;**login()**:&#10;```&#10;1. Find user by username&#10;2. Authenticate credentials (AuthenticationManager)&#10;3. Generate JWT token (JwtService)&#10;4. Build LoginResponseDTO with token + user info&#10;5. Return response (controller sets cookie)&#10;```&#10;&#10;**getOnlineUsers()**:&#10;```&#10;1. Query: SELECT * FROM users WHERE is_online = true&#10;2. Convert to Map&lt;username, User&gt;&#10;3. Return map&#10;```&#10;&#10;#### UserService.java&#10;&#10;**Key Methods**:&#10;- `userExists(username)`: Check if user exists&#10;- `setUserOnlineStatus(username, boolean)`: Update online status&#10;- Used by ChatController and WebSocketListener&#10;&#10;#### CustomUserDetails.java&#10;&#10;**Purpose**: Implements `UserDetailsService` for Spring Security&#10;&#10;**Flow**:&#10;```&#10;1. Spring Security requests user details by username&#10;2. Load user from UserRepository&#10;3. Convert to UserDetails object&#10;4. Return with authorities/roles&#10;```&#10;&#10;### 6. Models&#10;&#10;#### User Entity&#10;&#10;**Table**: `users`&#10;&#10;| Column | Type | Constraints | Description |&#10;|--------|------|-------------|-------------|&#10;| id | Long | PK, Auto-increment | Primary key |&#10;| username | String | UNIQUE, NOT NULL | User's unique identifier |&#10;| password | String | NOT NULL | BCrypt hashed password |&#10;| email | String | UNIQUE, NOT NULL | User's email |&#10;| is_online | boolean | NOT NULL | Online status flag |&#10;&#10;**Indexes**: &#10;- Unique on `username`&#10;- Unique on `email`&#10;&#10;#### ChatMessage Entity&#10;&#10;**Table**: `chat_messages`&#10;&#10;| Column | Type | Constraints | Description |&#10;|--------|------|-------------|-------------|&#10;| id | Long | PK, Auto-increment | Primary key |&#10;| content | String | - | Message content |&#10;| sender | String | - | Username of sender |&#10;| recipient | String | - | Username of recipient (null for public) |&#10;| color | String | - | Sender's color (UI) |&#10;| timestamp | LocalDateTime | NOT NULL | Message timestamp |&#10;| type | MessageType | ENUM | CHAT, PRIVATE_MESSAGE, JOIN, LEAVE, TYPING |&#10;&#10;**Message Types**:&#10;- `CHAT`: Public message&#10;- `PRIVATE_MESSAGE`: Direct message&#10;- `JOIN`: User joined notification&#10;- `LEAVE`: User left notification&#10;- `TYPING`: Typing indicator&#10;&#10;### 7. Repositories&#10;&#10;#### UserRepository.java&#10;&#10;```java&#10;interface UserRepository extends JpaRepository&lt;User, Long&gt; {&#10;    Optional&lt;User&gt; findByUsername(String username);&#10;    List&lt;User&gt; findByIsOnlineTrue();&#10;}&#10;```&#10;&#10;**Methods**:&#10;- `findByUsername()`: Used for authentication and user lookup&#10;- `findByIsOnlineTrue()`: Get all currently online users&#10;&#10;#### ChatMessageRepository.java&#10;&#10;```java&#10;interface ChatMessageRepository extends JpaRepository&lt;ChatMessage, Long&gt; {&#10;    @Query(&quot;SELECT m FROM ChatMessage m WHERE ...&quot;)&#10;    List&lt;ChatMessage&gt; findPrivateMessagesBetweenTwoUsers(String user1, String user2);&#10;}&#10;```&#10;&#10;**Custom Query**: Retrieves bidirectional chat history between two users&#10;&#10;### 8. Listeners&#10;&#10;#### WebSocketListener.java&#10;&#10;**Purpose**: Handles WebSocket lifecycle events&#10;&#10;**Events Handled**:&#10;&#10;1. **SessionConnectedEvent**&#10;   - Triggered when WebSocket connection established&#10;   - Logs connection&#10;&#10;2. **SessionDisconnectEvent**&#10;   - Triggered when WebSocket connection closed&#10;   - Extracts username from session&#10;   - Sets user online status = false&#10;   - Creates LEAVE message&#10;   - Broadcasts to /topic/public&#10;&#10;**Flow on Disconnect**:&#10;```&#10;1. WebSocket connection lost&#10;2. Extract username from session attributes&#10;3. Update user.isOnline = false&#10;4. Create ChatMessage (type: LEAVE)&#10;5. Broadcast to /topic/public&#10;6. All clients receive notification&#10;7. UI updates to show user offline&#10;```&#10;&#10;### 9. Configuration Files&#10;&#10;#### application.yml&#10;&#10;```yaml&#10;spring:&#10;  datasource:&#10;    url: jdbc:h2:mem:realchatapplication&#10;    driver: org.h2.Driver&#10;    username: USERNAME&#10;    password: PASSWORD&#10;  jpa:&#10;    hibernate:&#10;      ddl-auto: create-drop  # Recreates schema on restart&#10;    show-sql: true           # Log SQL queries&#10;  h2:&#10;    console:&#10;      enabled: true          # H2 Console at /h2-console&#10;      &#10;jwt:&#10;  secret: FGW390@#7&amp;Ounjkebu!#%%GHOPQasx&amp;Q&#10;  expiration: 3600000        # 1 hour in milliseconds&#10;```&#10;&#10;**Database Mode**: In-memory (data lost on restart)&#10;**Schema Management**: Auto-created from entities&#10;&#10;---&#10;&#10;## Frontend Deep Dive&#10;&#10;### 1. Application Structure&#10;&#10;```&#10;src/&#10;├── components/&#10;│   ├── Navbar.jsx           # Navigation bar&#10;│   └── ProtectedRoute.jsx   # Route guard for auth&#10;├── pages/&#10;│   ├── MainPage.jsx         # Landing page&#10;│   ├── Login.jsx            # Login form&#10;│   ├── Signup.jsx           # Registration form&#10;│   ├── ChatArea.jsx         # Public chat interface&#10;│   └── PrivateChat.jsx      # Private chat interface&#10;├── services/&#10;│   └── authService.js       # Authentication &amp; HTTP utilities&#10;├── styles/                  # CSS modules&#10;├── App.jsx                  # Main app component&#10;└── main.jsx                 # Entry point&#10;```&#10;&#10;### 2. Routing&#10;&#10;**File**: `App.jsx`&#10;&#10;```&#10;/                 → MainPage (public)&#10;/login            → Login (public)&#10;/signup           → Signup (public)&#10;/chatarea         → ChatArea (protected)&#10;```&#10;&#10;**Protected Routes**: Use `ProtectedRoute` component&#10;- Checks for authentication&#10;- Redirects to `/login` if not authenticated&#10;&#10;### 3. Authentication Service&#10;&#10;**File**: `authService.js`&#10;&#10;**Axios Configuration**:&#10;```javascript&#10;const api = axios.create({&#10;    baseURL: 'http://localhost:8080',&#10;    withCredentials: true  // Send cookies with requests&#10;});&#10;```&#10;&#10;**Key Functions**:&#10;&#10;1. **login(username, password)**&#10;   ```&#10;   1. POST /auth/login&#10;   2. Receive UserDTO&#10;   3. Generate random color for user&#10;   4. Store in localStorage:&#10;      - currentUser (with color)&#10;      - user (original response)&#10;   5. Return success + user data&#10;   ```&#10;&#10;2. **signup(username, email, password)**&#10;   ```&#10;   1. POST /auth/signup&#10;   2. Receive UserDTO&#10;   3. Return success&#10;   ```&#10;&#10;3. **logout()**&#10;   ```&#10;   1. POST /auth/logout&#10;   2. Clear localStorage&#10;   3. Navigate to login&#10;   ```&#10;&#10;4. **isAuthenticated()**&#10;   ```&#10;   Check if 'currentUser' exists in localStorage&#10;   ```&#10;&#10;5. **getOnlineUsers()**&#10;   ```&#10;   GET /auth/getonlineusers&#10;   Return map of online users&#10;   ```&#10;&#10;**Interceptor**: Global error handling&#10;- 401 → Auto-logout and redirect to login&#10;- 403/404/500 → Log error&#10;&#10;### 4. Chat Area Component&#10;&#10;**File**: `ChatArea.jsx`&#10;&#10;**State Management**:&#10;```javascript&#10;const [messages, setMessages] = useState([]);                // Public messages&#10;const [onlineUsers, setOnlineUsers] = useState(new Set());  // Online user list&#10;const [privateChats, setPrivateChats] = useState(new Map()); // Private chat windows&#10;const [unreadMessages, setUnreadMessages] = useState(new Map()); // Unread counts&#10;```&#10;&#10;**WebSocket Connection Flow**:&#10;&#10;```&#10;1. Component mounts&#10;2. Create SockJS connection to http://localhost:8080/ws&#10;3. Create STOMP client over SockJS&#10;4. Connect with headers:&#10;   - client-id: username&#10;   - session-id: timestamp&#10;   - username: username&#10;5. On successful connection:&#10;   a. Subscribe to /topic/public&#10;   b. Subscribe to /user/{username}/queue/private&#10;   c. Send JOIN message to /app/chat.addUser&#10;   d. Fetch online users via REST API&#10;6. On message received:&#10;   a. Public: Add to messages array&#10;   b. Private: Route to appropriate handler or increment unread&#10;7. On disconnect:&#10;   a. Server broadcasts LEAVE message&#10;   b. All clients update UI&#10;```&#10;&#10;**Message Handling**:&#10;&#10;**Public Messages**:&#10;```javascript&#10;stompClient.subscribe('/topic/public', (msg) =&gt; {&#10;    const chatMessage = JSON.parse(msg.body);&#10;    &#10;    // Handle different message types&#10;    switch(chatMessage.type) {&#10;        case 'JOIN':&#10;            addUserToOnlineList(chatMessage.sender);&#10;            break;&#10;        case 'LEAVE':&#10;            removeUserFromOnlineList(chatMessage.sender);&#10;            break;&#10;        case 'TYPING':&#10;            showTypingIndicator(chatMessage.sender);&#10;            break;&#10;        default:&#10;            addMessageToUI(chatMessage);&#10;    }&#10;});&#10;```&#10;&#10;**Private Messages**:&#10;```javascript&#10;stompClient.subscribe(`/user/${username}/queue/private`, (msg) =&gt; {&#10;    const privateMessage = JSON.parse(msg.body);&#10;    const otherUser = privateMessage.sender === username &#10;        ? privateMessage.recipient &#10;        : privateMessage.sender;&#10;    &#10;    // If chat window is open&#10;    if (privateMessageHandlers.has(otherUser)) {&#10;        handler(privateMessage);&#10;    } else {&#10;        // Increment unread count&#10;        setUnreadMessages(prev =&gt; ({&#10;            ...prev,&#10;            [otherUser]: (prev[otherUser] || 0) + 1&#10;        }));&#10;    }&#10;});&#10;```&#10;&#10;**Sending Messages**:&#10;&#10;**Public**:&#10;```javascript&#10;const sendMessage = () =&gt; {&#10;    stompClient.send(&quot;/app/chat.sendMessage&quot;, {}, JSON.stringify({&#10;        sender: username,&#10;        content: message,&#10;        type: 'CHAT',&#10;        color: userColor&#10;    }));&#10;};&#10;```&#10;&#10;**Private**:&#10;```javascript&#10;const sendPrivateMessage = (recipient, content) =&gt; {&#10;    stompClient.send(&quot;/app/chat.sendPrivateMessage&quot;, {}, JSON.stringify({&#10;        sender: username,&#10;        recipient: recipient,&#10;        content: content,&#10;        type: 'PRIVATE_MESSAGE',&#10;        color: userColor&#10;    }));&#10;};&#10;```&#10;&#10;### 5. Private Chat Component&#10;&#10;**File**: `PrivateChat.jsx`&#10;&#10;**Features**:&#10;- Loads chat history from REST API&#10;- Displays messages in conversation format&#10;- Sends messages via WebSocket&#10;- Real-time message updates&#10;&#10;**Initialization Flow**:&#10;```&#10;1. Component mounts&#10;2. Fetch message history:&#10;   GET /api/messages/private?user1=currentUser&amp;user2=otherUser&#10;3. Register message handler with parent (ChatArea)&#10;4. Display messages&#10;5. Listen for new messages via handler&#10;```&#10;&#10;---&#10;&#10;## Data Flow &amp; Communication&#10;&#10;### 1. User Registration Flow&#10;&#10;```&#10;┌────────┐                  ┌────────────┐                 ┌──────────┐&#10;│Frontend│                  │  Backend   │                 │ Database │&#10;└───┬────┘                  └─────┬──────┘                 └────┬─────┘&#10;    │                             │                             │&#10;    │ POST /auth/signup           │                             │&#10;    │ {username, email, pass}     │                             │&#10;    ├────────────────────────────▶│                             │&#10;    │                             │                             │&#10;    │                             │ Check username unique       │&#10;    │                             ├────────────────────────────▶│&#10;    │                             │                             │&#10;    │                             │ Hash password (BCrypt)      │&#10;    │                             │                             │&#10;    │                             │ INSERT INTO users           │&#10;    │                             ├────────────────────────────▶│&#10;    │                             │                             │&#10;    │                             │ User saved                  │&#10;    │                             │◀────────────────────────────┤&#10;    │                             │                             │&#10;    │ 200 OK                      │                             │&#10;    │ {username, email, id}       │                             │&#10;    │◀────────────────────────────┤                             │&#10;    │                             │                             │&#10;    │ Navigate to /login          │                             │&#10;    │                             │                             │&#10;```&#10;&#10;### 2. User Login Flow&#10;&#10;```&#10;┌────────┐                  ┌────────────┐                 ┌──────────┐&#10;│Frontend│                  │  Backend   │                 │ Database │&#10;└───┬────┘                  └─────┬──────┘                 └────┬─────┘&#10;    │                             │                             │&#10;    │ POST /auth/login            │                             │&#10;    │ {username, password}        │                             │&#10;    ├────────────────────────────▶│                             │&#10;    │                             │                             │&#10;    │                             │ Find user by username       │&#10;    │                             ├────────────────────────────▶│&#10;    │                             │                             │&#10;    │                             │ User entity                 │&#10;    │                             │◀────────────────────────────┤&#10;    │                             │                             │&#10;    │                             │ Verify password hash        │&#10;    │                             │ (BCrypt.matches)            │&#10;    │                             │                             │&#10;    │                             │ Generate JWT token          │&#10;    │                             │ (sign with secret key)      │&#10;    │                             │                             │&#10;    │ 200 OK                      │                             │&#10;    │ Set-Cookie: JWT=token       │                             │&#10;    │ {username, email, id}       │                             │&#10;    │◀────────────────────────────┤                             │&#10;    │                             │                             │&#10;    │ Store user + color in       │                             │&#10;    │ localStorage                │                             │&#10;    │                             │                             │&#10;    │ Navigate to /chatarea       │                             │&#10;    │                             │                             │&#10;```&#10;&#10;### 3. WebSocket Connection Flow&#10;&#10;```&#10;┌────────┐                  ┌────────────┐                 ┌──────────┐&#10;│Frontend│                  │  Backend   │                 │ Database │&#10;└───┬────┘                  └─────┬──────┘                 └────┬─────┘&#10;    │                             │                             │&#10;    │ Connect to /ws (SockJS)     │                             │&#10;    ├────────────────────────────▶│                             │&#10;    │                             │                             │&#10;    │ STOMP CONNECT frame         │                             │&#10;    ├────────────────────────────▶│                             │&#10;    │                             │                             │&#10;    │ CONNECTED frame             │                             │&#10;    │◀────────────────────────────┤                             │&#10;    │                             │                             │&#10;    │ SUBSCRIBE /topic/public     │                             │&#10;    ├────────────────────────────▶│                             │&#10;    │                             │                             │&#10;    │ SUBSCRIBE /user/{u}/queue   │                             │&#10;    ├────────────────────────────▶│                             │&#10;    │                             │                             │&#10;    │ SEND /app/chat.addUser      │                             │&#10;    │ {sender: user, type: JOIN}  │                             │&#10;    ├────────────────────────────▶│                             │&#10;    │                             │                             │&#10;    │                             │ Store username in session   │&#10;    │                             │                             │&#10;    │                             │ UPDATE users                │&#10;    │                             │ SET is_online = true        │&#10;    │                             ├────────────────────────────▶│&#10;    │                             │                             │&#10;    │                             │ INSERT INTO chat_messages   │&#10;    │                             ├────────────────────────────▶│&#10;    │                             │                             │&#10;    │                             │ Broadcast to /topic/public  │&#10;    │ MESSAGE (JOIN)              │                             │&#10;    │◀────────────────────────────┤                             │&#10;    │                             │                             │&#10;    │ Update UI (add user to      │                             │&#10;    │ online list)                │                             │&#10;    │                             │                             │&#10;```&#10;&#10;### 4. Public Message Flow&#10;&#10;```&#10;┌────────┐                  ┌────────────┐                 ┌──────────┐&#10;│Frontend│                  │  Backend   │                 │ Database │&#10;└───┬────┘                  └─────┬──────┘                 └────┬─────┘&#10;    │                             │                             │&#10;    │ User types message          │                             │&#10;    │                             │                             │&#10;    │ SEND /app/chat.sendMessage  │                             │&#10;    │ {sender, content, type}     │                             │&#10;    ├────────────────────────────▶│                             │&#10;    │                             │                             │&#10;    │                             │ Validate sender exists      │&#10;    │                             ├────────────────────────────▶│&#10;    │                             │                             │&#10;    │                             │ User found                  │&#10;    │                             │◀────────────────────────────┤&#10;    │                             │                             │&#10;    │                             │ Set timestamp               │&#10;    │                             │                             │&#10;    │                             │ INSERT INTO chat_messages   │&#10;    │                             ├────────────────────────────▶│&#10;    │                             │                             │&#10;    │                             │ Message ID returned         │&#10;    │                             │◀────────────────────────────┤&#10;    │                             │                             │&#10;    │                             │ Broadcast to /topic/public  │&#10;    │                             │ (all subscribers)           │&#10;    │ MESSAGE                     │                             │&#10;    │◀────────────────────────────┤                             │&#10;    │                             │                             │&#10;    │ Display in chat UI          │                             │&#10;    │                             │                             │&#10;```&#10;&#10;**Note**: All connected clients (including sender) receive the message&#10;&#10;### 5. Private Message Flow&#10;&#10;```&#10;┌─────────┐             ┌────────────┐            ┌──────────┐            ┌─────────┐&#10;│Frontend │             │  Backend   │            │ Database │            │Frontend │&#10;│(Sender) │             │            │            │          │            │(Recvr)  │&#10;└────┬────┘             └─────┬──────┘            └────┬─────┘            └────┬────┘&#10;     │                        │                        │                       │&#10;     │ SEND /app/chat.        │                        │                       │&#10;     │ sendPrivateMessage     │                        │                       │&#10;     ├───────────────────────▶│                        │                       │&#10;     │ {sender, recipient,    │                        │                       │&#10;     │  content, type}        │                        │                       │&#10;     │                        │                        │                       │&#10;     │                        │ Validate sender &amp;      │                       │&#10;     │                        │ recipient exist        │                       │&#10;     │                        ├───────────────────────▶│                       │&#10;     │                        │                        │                       │&#10;     │                        │ Both found             │                       │&#10;     │                        │◀───────────────────────┤                       │&#10;     │                        │                        │                       │&#10;     │                        │ Set type =             │                       │&#10;     │                        │ PRIVATE_MESSAGE        │                       │&#10;     │                        │                        │                       │&#10;     │                        │ INSERT INTO            │                       │&#10;     │                        │ chat_messages          │                       │&#10;     │                        ├───────────────────────▶│                       │&#10;     │                        │                        │                       │&#10;     │                        │ Message saved (ID)     │                       │&#10;     │                        │◀───────────────────────┤                       │&#10;     │                        │                        │                       │&#10;     │                        │ Send to recipient:     │                       │&#10;     │                        │ /user/{recipient}/     │                       │&#10;     │                        │ queue/private          │                       │&#10;     │                        ├───────────────────────────────────────────────▶│&#10;     │                        │                        │                       │&#10;     │                        │                        │            MESSAGE    │&#10;     │                        │                        │        (display in UI)│&#10;     │                        │                        │                       │&#10;     │                        │ Send to sender:        │                       │&#10;     │ MESSAGE                │ /user/{sender}/queue   │                       │&#10;     │◀───────────────────────┤                        │                       │&#10;     │                        │                        │                       │&#10;     │ Display in chat UI     │                        │                       │&#10;     │ (confirmation)         │                        │                       │&#10;     │                        │                        │                       │&#10;```&#10;&#10;**Why send to both?**&#10;- Sender: Confirmation &amp; sync across multiple devices/tabs&#10;- Recipient: Deliver the actual message&#10;&#10;### 6. User Disconnect Flow&#10;&#10;```&#10;┌────────┐                  ┌────────────┐                 ┌──────────┐&#10;│Frontend│                  │  Backend   │                 │ Database │&#10;└───┬────┘                  └─────┬──────┘                 └────┬─────┘&#10;    │                             │                             │&#10;    │ WebSocket connection lost   │                             │&#10;    │ (user closes tab/browser)   │                             │&#10;    ├────────────────────────────▶│                             │&#10;    │                             │                             │&#10;    │                             │ SessionDisconnectEvent      │&#10;    │                             │ triggered                   │&#10;    │                             │                             │&#10;    │                             │ Extract username from       │&#10;    │                             │ session attributes          │&#10;    │                             │                             │&#10;    │                             │ UPDATE users                │&#10;    │                             │ SET is_online = false       │&#10;    │                             │ WHERE username = ?          │&#10;    │                             ├────────────────────────────▶│&#10;    │                             │                             │&#10;    │                             │ Updated                     │&#10;    │                             │◀────────────────────────────┤&#10;    │                             │                             │&#10;    │                             │ Create LEAVE message        │&#10;    │                             │                             │&#10;    │                             │ Broadcast to /topic/public  │&#10;    │ MESSAGE (LEAVE)             │                             │&#10;    │◀────────────────────────────┤                             │&#10;    │                             │                             │&#10;    │ Update UI                   │                             │&#10;    │ (remove from online list)   │                             │&#10;    │                             │                             │&#10;```&#10;&#10;---&#10;&#10;## Security Implementation&#10;&#10;### 1. Authentication Flow&#10;&#10;```&#10;┌─────────────────────────────────────────────────────────────────┐&#10;│                    Spring Security Filter Chain                 │&#10;└─────────────────────────────────────────────────────────────────┘&#10;                              │&#10;                              ▼&#10;                    ┌──────────────────┐&#10;                    │   CORS Filter    │&#10;                    │  (Allow origins) │&#10;                    └────────┬─────────┘&#10;                             │&#10;                             ▼&#10;                ┌────────────────────────────┐&#10;                │  JwtAuthenticationFilter   │&#10;                │                            │&#10;                │  1. Extract JWT from       │&#10;                │     Cookie header          │&#10;                │  2. Validate signature     │&#10;                │  3. Check expiration       │&#10;                │  4. Extract username       │&#10;                │  5. Load UserDetails       │&#10;                │  6. Create Authentication  │&#10;                │  7. Set SecurityContext    │&#10;                └────────┬───────────────────┘&#10;                         │&#10;                         ▼&#10;          ┌──────────────────────────────────┐&#10;          │  Is user authenticated?          │&#10;          └──────────┬───────────┬───────────┘&#10;                     │           │&#10;                  YES│           │NO&#10;                     │           │&#10;                     ▼           ▼&#10;            ┌────────────┐  ┌─────────────┐&#10;            │  Proceed   │  │ Return 401  │&#10;            │  to        │  │ Unauthorized│&#10;            │ Controller │  └─────────────┘&#10;            └────────────┘&#10;```&#10;&#10;### 2. JWT Token Structure&#10;&#10;**Header**:&#10;```json&#10;{&#10;  &quot;alg&quot;: &quot;HS256&quot;,&#10;  &quot;typ&quot;: &quot;JWT&quot;&#10;}&#10;```&#10;&#10;**Payload**:&#10;```json&#10;{&#10;  &quot;sub&quot;: &quot;username&quot;,&#10;  &quot;userId&quot;: &quot;123&quot;,&#10;  &quot;iat&quot;: 1699999999,&#10;  &quot;exp&quot;: 1700003599&#10;}&#10;```&#10;&#10;**Signature**:&#10;```&#10;HMACSHA256(&#10;  base64UrlEncode(header) + &quot;.&quot; +&#10;  base64UrlEncode(payload),&#10;  secret&#10;)&#10;```&#10;&#10;### 3. Password Security&#10;&#10;**Hashing Algorithm**: BCrypt&#10;- **Cost Factor**: 10 (default)&#10;- **Salt**: Automatically generated per password&#10;- **Example Hash**: `$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy`&#10;&#10;**BCrypt Properties**:&#10;- Slow by design (prevents brute force)&#10;- Adaptive (cost factor can increase over time)&#10;- Salted (prevents rainbow table attacks)&#10;&#10;### 4. CORS Configuration&#10;&#10;**Allowed Origins**: `*` (all patterns)&#10;**Allowed Methods**: GET, POST, PUT, DELETE, OPTIONS&#10;**Allowed Headers**: `*`&#10;**Allow Credentials**: `true`&#10;**Exposed Headers**: `Set-Cookie`&#10;&#10;**Production Recommendation**: Restrict origins to specific domains&#10;&#10;### 5. Security Best Practices Implemented&#10;&#10;✅ **Stateless Authentication**: No server-side sessions&#10;✅ **HttpOnly Cookies**: JavaScript cannot access JWT&#10;✅ **CSRF Protection**: SameSite=Strict cookie attribute&#10;✅ **Password Hashing**: BCrypt with salt&#10;✅ **Token Expiration**: 1 hour lifetime&#10;✅ **Authorization on Every Request**: JWT validated per request&#10;✅ **Protected WebSocket**: Only authenticated users can connect&#10;&#10;⚠️ **Improvements for Production**:&#10;- HTTPS enforcement&#10;- Refresh token mechanism&#10;- Rate limiting&#10;- Input validation/sanitization&#10;- SQL injection prevention (use PreparedStatements)&#10;- XSS protection headers&#10;&#10;---&#10;&#10;## WebSocket Communication&#10;&#10;### 1. STOMP Protocol&#10;&#10;**STOMP** (Simple Text Oriented Messaging Protocol) is a simple text-based protocol built on top of WebSocket.&#10;&#10;**Key Concepts**:&#10;&#10;- **Destination**: Where messages are sent/received (like channels)&#10;- **Subscription**: Client registers interest in a destination&#10;- **Message**: Unit of data sent between client and server&#10;&#10;**STOMP Commands**:&#10;- `CONNECT`: Establish connection&#10;- `SUBSCRIBE`: Listen to a destination&#10;- `SEND`: Send message to a destination&#10;- `MESSAGE`: Server sends message to client&#10;- `DISCONNECT`: Close connection&#10;&#10;### 2. Destination Types&#10;&#10;#### Public Broadcast: `/topic/*`&#10;- One-to-many communication&#10;- All subscribers receive the message&#10;- Use case: Public chat room&#10;&#10;**Example**:&#10;```&#10;Client A sends to /app/chat.sendMessage&#10;→ Server broadcasts to /topic/public&#10;→ Clients A, B, C, D all receive the message&#10;```&#10;&#10;#### Point-to-Point: `/queue/*`&#10;- One-to-one communication&#10;- Only specific user receives the message&#10;- Use case: Notifications&#10;&#10;#### User-Specific: `/user/{username}/*`&#10;- Messages targeted to specific user&#10;- Spring converts `/user/{username}/queue/private` to session-specific destination&#10;- Use case: Private messages&#10;&#10;**How it works**:&#10;```&#10;1. User &quot;alice&quot; subscribes to /user/alice/queue/private&#10;2. Server maps this to session-specific destination (internal)&#10;3. When message sent to /user/alice/queue/private:&#10;   → Spring looks up alice's WebSocket session(s)&#10;   → Delivers message only to alice's session(s)&#10;```&#10;&#10;### 3. Message Flow Diagram&#10;&#10;```&#10;┌───────────────────────────────────────────────────────────────┐&#10;│                        Client Side                            │&#10;└───────────────────────────────────────────────────────────────┘&#10;                              │&#10;                              │ 1. Send message&#10;                              │&#10;                              ▼&#10;                    ┌──────────────────┐&#10;                    │  Application     │&#10;                    │  Destination     │&#10;                    │  /app/*          │&#10;                    └────────┬─────────┘&#10;                             │&#10;                             │ 2. Route to @MessageMapping&#10;                             │&#10;                             ▼&#10;┌───────────────────────────────────────────────────────────────┐&#10;│                      Server Side                              │&#10;│  ┌──────────────────────────────────────────────────────┐    │&#10;│  │            ChatController                             │    │&#10;│  │                                                       │    │&#10;│  │  @MessageMapping(&quot;/chat.sendMessage&quot;)                │    │&#10;│  │  @SendTo(&quot;/topic/public&quot;)                            │    │&#10;│  │  public ChatMessage sendMessage(ChatMessage msg) {   │    │&#10;│  │      // Save to DB                                   │    │&#10;│  │      return msg;  // Broadcast to /topic/public      │    │&#10;│  │  }                                                    │    │&#10;│  └──────────────────────────────────────────────────────┘    │&#10;│                             │                                 │&#10;│                             │ 3. Return value sent to broker  │&#10;│                             │                                 │&#10;│                             ▼                                 │&#10;│                    ┌──────────────────┐                       │&#10;│                    │  Message Broker  │                       │&#10;│                    │  (Simple/STOMP)  │                       │&#10;│                    └────────┬─────────┘                       │&#10;│                             │                                 │&#10;└─────────────────────────────┼─────────────────────────────────┘&#10;                              │&#10;                              │ 4. Broadcast to subscribers&#10;                              │&#10;        ┌─────────────────────┼─────────────────────┐&#10;        │                     │                     │&#10;        ▼                     ▼                     ▼&#10;┌──────────────┐      ┌──────────────┐     ┌──────────────┐&#10;│  Client A    │      │  Client B    │     │  Client C    │&#10;│  (subscribed)│      │  (subscribed)│     │  (subscribed)│&#10;└──────────────┘      └──────────────┘     └──────────────┘&#10;```&#10;&#10;### 4. SockJS Fallback&#10;&#10;**Why SockJS?**&#10;- Not all browsers/networks support WebSocket&#10;- Corporate firewalls may block WebSocket&#10;- Proxy servers may interfere&#10;&#10;**SockJS Fallbacks** (in order):&#10;1. **WebSocket**: Native browser support (preferred)&#10;2. **HTTP Streaming**: Keeps HTTP connection open&#10;3. **HTTP Long Polling**: Polls server for new messages&#10;4. **JSONP Polling**: Cross-domain polling (last resort)&#10;&#10;**Transparent to Application**:&#10;- Client/server code remains the same&#10;- SockJS handles protocol negotiation&#10;&#10;---&#10;&#10;## Database Schema&#10;&#10;### Entity Relationship Diagram&#10;&#10;```&#10;┌─────────────────────────────────┐&#10;│            users                │&#10;├─────────────────────────────────┤&#10;│ PK │ id           │ BIGINT      │&#10;│    │ username     │ VARCHAR     │ UNIQUE&#10;│    │ password     │ VARCHAR     │&#10;│    │ email        │ VARCHAR     │ UNIQUE&#10;│    │ is_online    │ BOOLEAN     │&#10;└─────────────────────────────────┘&#10;               │&#10;               │ (1) user can send many messages&#10;               │&#10;               │&#10;┌──────────────▼──────────────────┐&#10;│        chat_messages            │&#10;├─────────────────────────────────┤&#10;│ PK │ id           │ BIGINT      │&#10;│    │ content      │ VARCHAR     │&#10;│    │ sender       │ VARCHAR     │ → users.username&#10;│    │ recipient    │ VARCHAR     │ → users.username (nullable)&#10;│    │ color        │ VARCHAR     │&#10;│    │ timestamp    │ DATETIME    │&#10;│    │ type         │ VARCHAR     │ ENUM&#10;└─────────────────────────────────┘&#10;```&#10;&#10;**Relationship**: One-to-Many (User → Messages)&#10;- Not enforced with foreign keys (username stored as string)&#10;- Allows flexibility but requires application-level validation&#10;&#10;### SQL Schema (Auto-generated by Hibernate)&#10;&#10;```sql&#10;CREATE TABLE users (&#10;    id BIGINT AUTO_INCREMENT PRIMARY KEY,&#10;    username VARCHAR(255) NOT NULL UNIQUE,&#10;    password VARCHAR(255) NOT NULL,&#10;    email VARCHAR(255) NOT NULL UNIQUE,&#10;    is_online BOOLEAN NOT NULL DEFAULT FALSE&#10;);&#10;&#10;CREATE TABLE chat_messages (&#10;    id BIGINT AUTO_INCREMENT PRIMARY KEY,&#10;    content VARCHAR(255),&#10;    sender VARCHAR(255),&#10;    recipient VARCHAR(255),&#10;    color VARCHAR(50),&#10;    timestamp TIMESTAMP NOT NULL,&#10;    type VARCHAR(50)&#10;);&#10;&#10;CREATE INDEX idx_sender ON chat_messages(sender);&#10;CREATE INDEX idx_recipient ON chat_messages(recipient);&#10;CREATE INDEX idx_timestamp ON chat_messages(timestamp);&#10;```&#10;&#10;**Indexes** (recommended for performance):&#10;- `sender`: Fast lookup of messages sent by user&#10;- `recipient`: Fast lookup of messages received by user&#10;- `timestamp`: Ordered retrieval of messages&#10;&#10;### Sample Data&#10;&#10;**users**:&#10;```&#10;| id | username | password                      | email           | is_online |&#10;|----|----------|-------------------------------|-----------------|-----------|&#10;| 1  | alice    | $2a$10$ABC...encrypted...XYZ       | alice@test.com  | true      |&#10;| 2  | bob      | $2a$10$DEF...encrypted...UVW       | bob@test.com    | true      |&#10;| 3  | charlie  | $2a$10$GHI...encrypted...RST       | charlie@test.com| false     |&#10;```&#10;&#10;**chat_messages**:&#10;```&#10;| id | content          | sender  | recipient | type            | timestamp           |&#10;|----|------------------|---------|-----------|-----------------|---------------------|&#10;| 1  | &quot;&quot;               | alice   | NULL      | JOIN            | 2024-11-14 10:00:00 |&#10;| 2  | &quot;Hello everyone!&quot;| alice   | NULL      | CHAT            | 2024-11-14 10:00:05 |&#10;| 3  | &quot;&quot;               | bob     | NULL      | JOIN            | 2024-11-14 10:01:00 |&#10;| 4  | &quot;Hi Alice!&quot;      | bob     | alice     | PRIVATE_MESSAGE | 2024-11-14 10:01:30 |&#10;| 5  | &quot;Hey Bob!&quot;       | alice   | bob       | PRIVATE_MESSAGE | 2024-11-14 10:01:45 |&#10;```&#10;&#10;---&#10;&#10;## Key Features Implementation&#10;&#10;### 1. User Online Status&#10;&#10;**Mechanism**:&#10;- `users.is_online` boolean field&#10;- Updated on WebSocket connect/disconnect&#10;&#10;**Flow**:&#10;```&#10;User connects → is_online = true&#10;User disconnects → is_online = false&#10;```&#10;&#10;**Frontend Display**:&#10;```javascript&#10;const OnlineUserList = ({ users }) =&gt; {&#10;    return users.map(user =&gt; (&#10;        &lt;div className=&quot;user-item&quot;&gt;&#10;            &lt;span className=&quot;status-indicator online&quot;&gt;&lt;/span&gt;&#10;            {user}&#10;        &lt;/div&gt;&#10;    ));&#10;};&#10;```&#10;&#10;**Polling** (optional):&#10;- Frontend can periodically call `/auth/getonlineusers`&#10;- Real-time updates via JOIN/LEAVE messages preferred&#10;&#10;### 2. Private Messaging&#10;&#10;**Implementation Details**:&#10;&#10;**Database**:&#10;- `recipient` field stores target username&#10;- Query retrieves bidirectional messages:&#10;  ```sql&#10;  WHERE (sender = 'alice' AND recipient = 'bob')&#10;     OR (sender = 'bob' AND recipient = 'alice')&#10;  ```&#10;&#10;**WebSocket Routing**:&#10;- Server sends to both parties:&#10;  - `/user/alice/queue/private`&#10;  - `/user/bob/queue/private`&#10;&#10;**Frontend State**:&#10;```javascript&#10;const [privateChats, setPrivateChats] = useState(new Map());&#10;// Map structure:&#10;// {&#10;//   &quot;bob&quot;: { messages: [...], unread: 0 },&#10;//   &quot;charlie&quot;: { messages: [...], unread: 2 }&#10;// }&#10;```&#10;&#10;**Opening Private Chat**:&#10;```&#10;1. User clicks on username in online list&#10;2. Fetch message history from REST API&#10;3. Register message handler for real-time updates&#10;4. Display chat window&#10;5. Send messages via WebSocket&#10;```&#10;&#10;### 3. Message Persistence&#10;&#10;**Why Save Messages?**&#10;- Chat history retrieval&#10;- Offline message delivery (future feature)&#10;- Analytics/monitoring&#10;&#10;**When Messages Are Saved**:&#10;- Public messages: On send (in `ChatController.sendMessage()`)&#10;- Private messages: On send (in `ChatController.sendPrivateMessage()`)&#10;- Join/Leave: On event (in `ChatController.addUser()`, `WebSocketListener`)&#10;&#10;**Timestamp Handling**:&#10;```java&#10;if (chatMessage.getTimestamp() == null) {&#10;    chatMessage.setTimestamp(LocalDateTime.now());&#10;}&#10;```&#10;&#10;**Database**: H2 in-memory (data lost on restart)&#10;**Production**: Switch to PostgreSQL/MySQL for persistence&#10;&#10;### 4. Typing Indicators (Partial Implementation)&#10;&#10;**Message Type**: `TYPING`&#10;&#10;**Flow**:&#10;```&#10;1. User types in input field&#10;2. Debounced event sends TYPING message&#10;3. Other users see &quot;User is typing...&quot; indicator&#10;4. Indicator removed after 2 seconds&#10;```&#10;&#10;**Frontend Implementation**:&#10;```javascript&#10;const handleTyping = () =&gt; {&#10;    if (typingTimeout) clearTimeout(typingTimeout);&#10;    &#10;    // Send typing indicator&#10;    stompClient.send(&quot;/app/chat.sendMessage&quot;, {}, JSON.stringify({&#10;        sender: username,&#10;        type: 'TYPING'&#10;    }));&#10;    &#10;    // Auto-clear after 2 seconds&#10;    setTypingTimeout(setTimeout(() =&gt; {&#10;        setIsTyping('');&#10;    }, 2000));&#10;};&#10;```&#10;&#10;### 5. User Colors&#10;&#10;**Purpose**: Visual distinction between users in chat&#10;&#10;**Implementation**:&#10;- Generated on login (frontend)&#10;- Stored in localStorage&#10;- Sent with each message&#10;- Displayed as sender name color&#10;&#10;**Color Palette**:&#10;```javascript&#10;const colors = [&#10;    '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',&#10;    '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'&#10;];&#10;```&#10;&#10;**CSS**:&#10;```css&#10;.message-sender {&#10;    color: var(--sender-color);&#10;    font-weight: bold;&#10;}&#10;```&#10;&#10;### 6. Emoji Support&#10;&#10;**Implementation**:&#10;```javascript&#10;const emojis = ['', '', '', '', '', '❤️', '', ''];&#10;&#10;const EmojiPicker = ({ onSelect }) =&gt; {&#10;    return (&#10;        &lt;div className=&quot;emoji-picker&quot;&gt;&#10;            {emojis.map(emoji =&gt; (&#10;                &lt;span onClick={() =&gt; onSelect(emoji)}&gt;{emoji}&lt;/span&gt;&#10;            ))}&#10;        &lt;/div&gt;&#10;    );&#10;};&#10;```&#10;&#10;**Inserting Emoji**:&#10;```javascript&#10;const insertEmoji = (emoji) =&gt; {&#10;    setMessage(prevMessage =&gt; prevMessage + emoji);&#10;};&#10;```&#10;&#10;---&#10;&#10;## Conclusion&#10;&#10;This documentation covers the complete internal architecture of the Echo messaging application. Key takeaways:&#10;&#10;1. **Backend**: Spring Boot with JWT authentication, WebSocket support, and RESTful APIs&#10;2. **Frontend**: React with real-time WebSocket connections and responsive UI&#10;3. **Communication**: STOMP over SockJS for reliable bidirectional messaging&#10;4. **Security**: Stateless JWT authentication with HttpOnly cookies&#10;5. **Database**: H2 in-memory (development), easily switchable to production DB&#10;&#10;The application demonstrates modern real-time web application patterns with clean separation of concerns, security best practices, and scalable architecture.&#10;&#10;---&#10;&#10;## Troubleshooting &amp; Common Issues&#10;&#10;### Backend Issues&#10;&#10;1. **Port 8080 already in use**&#10;   - Solution: Kill process or change port in `application.yml`&#10;&#10;2. **JWT signature verification failed**&#10;   - Check `jwt.secret` in `application.yml`&#10;   - Ensure same secret used for signing and verification&#10;&#10;3. **WebSocket connection refused**&#10;   - Verify `/ws` endpoint is accessible&#10;   - Check CORS configuration&#10;   - Ensure SockJS is enabled&#10;&#10;4. **User not authenticated**&#10;   - Check JWT cookie is being sent&#10;   - Verify token hasn't expired&#10;   - Check `JwtAuthenticationFilter` is in filter chain&#10;&#10;### Frontend Issues&#10;&#10;1. **Cannot connect to WebSocket**&#10;   - Verify backend is running on localhost:8080&#10;   - Check browser console for connection errors&#10;   - Ensure SockJS URL is correct&#10;&#10;2. **Messages not appearing**&#10;   - Check WebSocket subscription is active&#10;   - Verify message type is correct&#10;   - Check browser console for JavaScript errors&#10;&#10;3. **Login fails with CORS error**&#10;   - Ensure `withCredentials: true` in axios config&#10;   - Verify CORS configuration in `SecurityConfig.java`&#10;&#10;4. **Private messages not delivered**&#10;   - Check both users are connected to WebSocket&#10;   - Verify subscription to `/user/{username}/queue/private`&#10;   - Check message recipient is correct&#10;&#10;---&#10;&#10;## Future Enhancements&#10;&#10;- [ ] Message editing and deletion&#10;- [ ] File/image sharing&#10;- [ ] Group chats&#10;- [ ] Read receipts&#10;- [ ] Push notifications&#10;- [ ] Message search&#10;- [ ] User profiles and avatars&#10;- [ ] Persistent database (PostgreSQL)&#10;- [ ] Refresh token mechanism&#10;- [ ] End-to-end encryption&#10;- [ ] Mobile app (React Native)&#10;&#10;---&#10;&#10;**Document Version**: 1.0  &#10;**Last Updated**: November 14, 2024  &#10;**Author**: AI-Generated Documentation&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>